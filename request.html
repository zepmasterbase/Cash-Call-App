<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pay — CashCall</title>
  <meta name="description" content="Secure card payments (Paystack) for CashCall requests." />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Manrope:wght@600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg-1:#eef6fb;
      --bg-2:#ffffff;
      --card:#ffffff;
      --muted:#546b76;
      --accent-a:#00bcd4;
      --accent-b:#8450ff;
      --radius:14px;
      --maxw:420px;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; padding:0; background:linear-gradient(180deg,var(--bg-1),var(--bg-2)); font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial; -webkit-font-smoothing:antialiased; color:#06202b}
    body{ padding:18px; -webkit-text-size-adjust:100% }

    .wrap{ max-width:var(--maxw); margin:0 auto; }

    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:12px; border-radius:12px; background:rgba(255,255,255,0.95);
      border:1px solid rgba(7,32,44,0.06); box-shadow:0 10px 30px rgba(7,30,60,0.04);
      position:sticky; top:12px; z-index:30;
    }
    .brand { display:flex; gap:10px; align-items:center; }
    .logo { width:44px; height:44px; border-radius:10px; display:grid; place-items:center; background:linear-gradient(90deg,var(--accent-a),var(--accent-b)); color:#021026; font-weight:900; font-family:Manrope }
    .title { font-family:Manrope; font-weight:800; font-size:16px; margin:0 }

    main{ margin-top:12px; display:grid; gap:12px; }

    .card { background:var(--card); border-radius:14px; padding:14px; border:1px solid rgba(7,32,44,0.04); box-shadow:0 20px 50px rgba(7,30,60,0.04); }
    .meta { color:var(--muted); font-size:13px; margin-bottom:6px }
    .pay-amount { font-family:Manrope; font-size:30px; font-weight:800; margin:4px 0; color:#021026 }
    .desc { color:var(--muted); margin-top:6px; font-size:14px }

    .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    .btn { flex:1; padding:12px 14px; border-radius:12px; border:0; font-weight:800; cursor:pointer; }
    .btn-primary { background:linear-gradient(90deg,var(--accent-a),var(--accent-b)); color:#021026; box-shadow:0 12px 30px rgba(7,30,60,0.06); }
    .btn-ghost { background:transparent; border:1px solid rgba(7,32,44,0.06); color:var(--muted); font-weight:700 }

    .small { color:var(--muted); font-size:13px }
    .notice { border-radius:10px; padding:10px; background:linear-gradient(180deg,#fbfdff,#ffffff); border:1px solid rgba(7,32,44,0.03); color:var(--muted); font-size:13px }

    .spinner { display:inline-block; width:14px; height:14px; border-radius:50%; border:2px solid rgba(255,255,255,0.6); border-right-color:rgba(0,0,0,0.12); animation:spin .9s linear infinite; vertical-align:middle; margin-left:8px }
    @keyframes spin { to { transform: rotate(360deg) } }

    .success { color: #0a7a3c; font-weight:800 }
    .error { color:#b42318; font-weight:800 }

    .footer { margin-top:18px; text-align:center; color:var(--muted); font-size:13px }

    @media (max-width:380px){
      .pay-amount { font-size:24px }
    }
  </style>
</head>
<body>
  <div class="wrap" role="document">
    <header role="banner" aria-label="Top navigation">
      <div class="brand">
        <div class="logo" aria-hidden="true">C</div>
        <div>
          <p class="title">CashCall</p>
          <p class="small" id="payeeLabel" style="margin:0"></p>
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <a class="small" href="dashboard.html">Dashboard</a>
      </div>
    </header>

    <main>
      <section class="card" aria-labelledby="payHeading">
        <h2 id="payHeading" style="margin:0 0 6px 0; font-family:Manrope; font-size:18px">Confirm payment</h2>
        <div id="statusMsg" class="notice" role="status" aria-live="polite">Loading request…</div>

        <div id="requestBlock" style="display:none">
          <div class="meta">Request from <span id="requestorName" class="small"></span></div>
          <div id="amount" class="pay-amount">—</div>
          <div id="desc" class="desc">—</div>

          <div class="row" style="margin-top:16px">
            <button id="payBtn" class="btn btn-primary" aria-live="polite">Pay with card</button>
            <button id="copyLink" class="btn btn-ghost">Copy link</button>
          </div>

          <div style="margin-top:12px" id="afterActions" aria-hidden="true">
            <div id="resultMsg" class="small" role="status" aria-live="polite"></div>
          </div>
        </div>

      </section>

      <section class="card" aria-label="Help & info">
        <p class="small" style="margin:0 0 8px 0"><strong>Card payments only:</strong> This merchant accepts card payments. You will be redirected to a secure Paystack flow to enter card details.</p>
        <p class="small" style="margin:0">If you prefer, copy the payment link and open it in the app or share it with someone who will pay on your behalf.</p>
      </section>

      <div class="footer">
        <div id="footerMeta">Secure payment powered by your provider</div>
      </div>
    </main>
  </div>

  <!-- Paystack inline script (client uses public key only). The server is required to create the transaction. -->
  <script src="https://js.paystack.co/v1/inline.js"></script>

  <script>
    /**
     * pay.html (frontend)
     *
     * Responsibilities:
     * - Read request_id from URL (pay.html?request_id=...)
     * - Fetch request details (prefer server: GET /api/requests/:id). Fallback: localStorage cashcall_requests.
     * - Show request details to payee.
     * - On "Pay with card":
     *     -> call POST /api/payments/initiate { requestId }
     *     -> server initializes Paystack transaction (secret key) and returns either:
     *         { authorization_url } (redirect flow) OR { reference, publicKey, amount, email? }
     *     -> if authorization_url: redirect user to that URL
     *     -> if inline: call PaystackPop.setup({ key: publicKey, email, amount, ref: reference, callback, onClose })
     *     -> when callback returns, call GET /api/payments/verify/:reference (server verifies with secret key)
     *     -> display success/failure, update local UI and optionally mark request as paid through server endpoint.
     *
     * IMPORTANT:
     * - Never put Paystack secret key here.
     * - Do server-side verification (verify endpoint) and webhook processing on your backend.
     */

    // Storage & endpoints config
    const REQUESTS_KEY = 'cashcall_requests';
    const INITIATE_ENDPOINT = '/api/payments/initiate'; // POST { requestId }
    const VERIFY_ENDPOINT = '/api/payments/verify';     // POST { reference } or GET /api/payments/verify/:reference
    const GET_REQUEST_ENDPOINT = (id) => `/api/requests/${encodeURIComponent(id)}`; // optional server route

    // DOM
    const statusMsg = document.getElementById('statusMsg');
    const requestBlock = document.getElementById('requestBlock');
    const requestorNameEl = document.getElementById('requestorName');
    const amountEl = document.getElementById('amount');
    const descEl = document.getElementById('desc');
    const payBtn = document.getElementById('payBtn');
    const copyLink = document.getElementById('copyLink');
    const afterActions = document.getElementById('afterActions');
    const resultMsg = document.getElementById('resultMsg');
    const payeeLabel = document.getElementById('payeeLabel');

    // small helpers
    function qs(name) {
      return new URLSearchParams(location.search).get(name);
    }
    function showStatus(text, type = 'info') {
      statusMsg.textContent = text;
      if (type === 'error') statusMsg.style.borderColor = 'rgba(180,35,24,0.08)';
    }
    function formatCurrency(amount, currency) {
      try {
        return new Intl.NumberFormat(undefined, { style: 'currency', currency }).format(Number(amount));
      } catch (e) {
        return (currency ? currency + ' ' : '') + Number(amount).toFixed(2);
      }
    }

    // load request — prefer server, fallback to localStorage
    async function loadRequest(requestId) {
      if (!requestId) return null;

      // Attempt server fetch first (more authoritative)
      try {
        const resp = await fetch(GET_REQUEST_ENDPOINT(requestId), { method: 'GET', credentials: 'include' });
        if (resp.ok) {
          const json = await resp.json();
          if (json && json.id) return json;
        }
        // Non-OK falls through to local fallback
      } catch (err) {
        // network or CORS; fallback to local
        console.warn('Server request fetch failed, falling back to localStorage', err);
      }

      // fallback: read from localStorage
      try {
        const arr = JSON.parse(localStorage.getItem(REQUESTS_KEY) || '[]');
        return arr.find(r => r.id === requestId) || null;
      } catch (err) {
        return null;
      }
    }

    // initialize UI
    (async function init() {
      const requestId = qs('request_id');
      if (!requestId) {
        showStatus('Invalid payment link. No request id found.', 'error');
        return;
      }

      showStatus('Fetching request…');

      const req = await loadRequest(requestId);
      if (!req) {
        showStatus('Request not found or expired. Please ask the requester to resend the link.', 'error');
        return;
      }

      // populate UI
      requestBlock.style.display = 'block';
      requestorNameEl.textContent = req.requestorName || (req.requestor || 'Requester');
      amountEl.textContent = formatCurrency(req.amount, req.currency || 'USD');
      descEl.textContent = req.description || 'Payment request';
      payeeLabel.textContent = req.payee || '';
      showStatus('Ready to pay — secure checkout', 'info');

      // if already paid, show status and disable
      if (req.status === 'paid') {
        resultMsg.innerHTML = `<span class="success">This request has already been paid.</span>`;
        afterActions.setAttribute('aria-hidden', 'false');
        payBtn.disabled = true;
        copyLink.disabled = false;
      }

      // wire buttons
      payBtn.addEventListener('click', () => handlePayClick(req));
      copyLink.addEventListener('click', () => {
        const link = location.href;
        navigator.clipboard?.writeText(link).then(() => alert('Link copied'), () => prompt('Copy this link', link));
      });
    })();

    // handle pay button click
    async function handlePayClick(req) {
      payBtn.disabled = true;
      payBtn.innerHTML = 'Preparing… <span class="spinner" aria-hidden="true"></span>';
      resultMsg.textContent = '';

      try {
        // Initiate payment with backend
        // Payload: { requestId } — server will init Paystack transaction using secret key
        const resp = await fetch(INITIATE_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ requestId: req.id })
        });

        if (!resp.ok) {
          const text = await resp.text().catch(() => null);
          throw new Error(text || `Failed to initiate payment (${resp.status})`);
        }

        const init = await resp.json();
        // Expected responses:
        // 1) { authorization_url } -> redirect flow
        // 2) { reference, publicKey, amount, email? } -> inline flow
        // 3) { authorization_url, reference, publicKey } -> either

        // If server provided authorization_url — redirect user
        if (init.authorization_url) {
          // optional: record reference locally if provided
          showStatus('Redirecting to secure payment page…');
          window.location.href = init.authorization_url;
          return;
        }

        // Inline flow path
        if (!window.PaystackPop) {
          throw new Error('Paystack inline script not available.');
        }

        // Validate returned fields
        const publicKey = init.publicKey || init.public_key || init.pk;
        const reference = init.reference || init.ref || init.access_code;
        const amountFromServer = init.amount || Math.round(Number(req.amount) * 100); // server should return smallest unit
        const email = init.email || req.payee || 'customer@example.com';

        if (!publicKey || !reference) {
          throw new Error('Server did not return required paystack init data (publicKey/reference).');
        }

        // Open Paystack inline
        showStatus('Opening secure card entry…');
        const handler = PaystackPop.setup({
          key: publicKey,
          email: email,
          amount: amountFromServer, // in smallest currency unit (kobo/cents)
          ref: reference,
          metadata: {
            requestId: req.id
          },
          callback: async function(response) {
            // response.reference — verify on server
            showStatus('Payment completed — verifying…');
            payBtn.innerHTML = 'Verifying… <span class="spinner" aria-hidden="true"></span>';
            try {
              // Call verify endpoint (server-side should verify with secret key)
              const verifyResp = await fetch(`${VERIFY_ENDPOINT}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reference: response.reference })
              });
              if (!verifyResp.ok) {
                const txt = await verifyResp.text().catch(()=>null);
                throw new Error(txt || 'Verification failed');
              }
              const verifyJson = await verifyResp.json();
              // Server should return verification result: success/failed & transaction data
              if (verifyJson && (verifyJson.status === 'success' || verifyJson.data?.status === 'success')) {
                // mark local request paid (if stored locally) and show success
                markRequestPaid(req.id, response.reference);
                resultMsg.innerHTML = `<span class="success">Payment successful — reference ${escapeHtml(response.reference)}</span>`;
                afterActions.setAttribute('aria-hidden', 'false');
                showStatus('Payment confirmed. Redirecting to dashboard…');
                setTimeout(() => window.location.href = 'dashboard.html', 1200);
              } else {
                throw new Error('Payment not successful (server verification).');
              }
            } catch (errVer) {
              console.error('verify error', errVer);
              resultMsg.innerHTML = `<span class="error">Payment verification failed — ${escapeHtml(errVer.message || errVer)}</span>`;
              afterActions.setAttribute('aria-hidden', 'false');
            } finally {
              payBtn.disabled = false;
              payBtn.textContent = 'Pay with card';
            }
          },
          onClose: function() {
            payBtn.disabled = false;
            payBtn.textContent = 'Pay with card';
            showStatus('Payment cancelled — you can try again or copy the link.');
          }
        });
        handler.openIframe();

      } catch (err) {
        console.error('initiate error', err);
        resultMsg.innerHTML = `<span class="error">Error: ${escapeHtml(err.message || err)}</span>`;
        afterActions.setAttribute('aria-hidden', 'false');
        payBtn.disabled = false;
        payBtn.textContent = 'Pay with card';
        showStatus('Unable to start payment. Try again or contact support.', 'error');
      }
    }

    // mark request paid locally (best-effort). Permanent truth should come from server/webhook.
    function markRequestPaid(requestId, reference) {
      try {
        const arr = JSON.parse(localStorage.getItem(REQUESTS_KEY) || '[]');
        const idx = arr.findIndex(r => r.id === requestId);
        if (idx !== -1) {
          arr[idx].status = 'paid';
          arr[idx].paidAt = new Date().toISOString();
          arr[idx].paymentReference = reference;
          localStorage.setItem(REQUESTS_KEY, JSON.stringify(arr));
        }
      } catch (err) {
        console.warn('local mark paid failed', err);
      }
    }

    // small XSS-safe escape
    function escapeHtml(s) {
      if (!s) return '';
      return String(s).replace(/[&<>"']/g, (m)=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }
  </script>
</body>
</html>